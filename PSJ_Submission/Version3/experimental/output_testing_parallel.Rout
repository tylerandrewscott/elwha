
R version 3.2.0 (2015-04-16) -- "Full of Ingredients"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> #rm(list=ls())
> #rm(list=ls())
> 
> require(statnet)
Loading required package: statnet
Loading required package: network
network: Classes for Relational Data
Version 1.12.0 created on 2015-03-04.
copyright (c) 2005, Carter T. Butts, University of California-Irvine
                    Mark S. Handcock, University of California -- Los Angeles
                    David R. Hunter, Penn State University
                    Martina Morris, University of Washington
                    Skye Bender-deMoll, University of Washington
 For citation information, type citation("network").
 Type help("network-package") to get started.

Loading required package: ergm
Loading required package: statnet.common

ergm: version 3.2.4, created on 2014-12-13
Copyright (c) 2014, Mark S. Handcock, University of California -- Los Angeles
                    David R. Hunter, Penn State University
                    Carter T. Butts, University of California -- Irvine
                    Steven M. Goodreau, University of Washington
                    Pavel N. Krivitsky, University of Wollongong
                    Martina Morris, University of Washington
                    with contributions from
                    Li Wang
                    Kirk Li, University of Washington
Based on "statnet" project software (statnet.org).
For license and citation information see statnet.org/attribution
or type citation("ergm").

NOTE: If you use custom ERGM terms based on ‘ergm.userterms’ version
prior to 3.1, you will need to perform a one-time update of the package
boilerplate files (the files that you did not write or modify) from
‘ergm.userterms’ 3.1 or later. See help('eut-upgrade') for
instructions.

Loading required package: sna
sna: Tools for Social Network Analysis
Version 2.3-2 created on 2014-01-13.
copyright (c) 2005, Carter T. Butts, University of California-Irvine
 For citation information, type citation("sna").
 Type help(package="sna") to get started.


Attaching package: ‘sna’

The following object is masked from ‘package:network’:

    %c%

Loading required package: networkDynamic

networkDynamic: version 0.7.1, created on 2014-09-29
Copyright (c) 2014, Carter T. Butts, University of California -- Irvine
                    Ayn Leslie-Cook, University of Washington
                    Pavel N. Krivitsky, University of Wollongong
                    Skye Bender-deMoll, University of Washington
                    with contributions from
                    Zack Almquist, University of California -- Irvine
                    David R. Hunter, Penn State University
                    Li Wang
                    Kirk Li, University of Washington
                    Steven M. Goodreau, University of Washington
                    Jeffrey Horner
                    Martina Morris, University of Washington
Based on "statnet" project software (statnet.org).
For license and citation information see statnet.org/attribution
or type citation("networkDynamic").

Loading required package: tergm

tergm: version 3.2.4, created on 2014-12-13
Copyright (c) 2014, Pavel N. Krivitsky, University of Wollongong
                    Mark S. Handcock, University of California -- Los Angeles
                    with contributions from
                    David R. Hunter, Penn State University
                    Steven M. Goodreau, University of Washington
                    Martina Morris, University of Washington
                    Nicole Bohme Carnegie, New York University
                    Carter T. Butts, University of California -- Irvine
                    Ayn Leslie-Cook, University of Washington
                    Skye Bender-deMoll
                    Li Wang
                    Kirk Li, University of Washington
Based on "statnet" project software (statnet.org).
For license and citation information see statnet.org/attribution
or type citation("tergm").

Loading required package: ergm.count

ergm.count: version 3.1.1, created on 2013-03-29
Copyright (c) 2013, Pavel N. Krivitsky, University of Wollongong
                    with contributions from
                    Mark S. Handcock, University of California -- Los Angeles
                    David R. Hunter, Penn State University
Based on "statnet" project software (statnet.org).
For license and citation information see statnet.org/attribution
or type citation("ergm.count").

Loading required package: latentnet

latentnet: version 2.7.0, created on 2015-03-21
Copyright (c) 2015, Pavel N. Krivitsky, University of Wollongong
                    Mark S. Handcock, University of California -- Los Angeles
                    with contributions from
                    Susan M. Shortreed
                    Jeremy Tantrum
                    Peter D. Hoff
                    Li Wang
                    Kirk Li, University of Washington
Based on "statnet" project software (statnet.org).
For license and citation information see statnet.org/attribution
or type citation("latentnet").
NOTE: BIC calculation prior latentnet 2.7.0 had a bug in the calculation of the effective number of parameters. See help(summary.ergmm) for details.

statnet: version 2014.2.0, created on 2014-02-05
Copyright (c) 2014, Mark S. Handcock, University of California -- Los Angeles
                    David R. Hunter, Penn State University
                    Carter T. Butts, University of California -- Irvine
                    Steven M. Goodreau, University of Washington
                    Pavel N. Krivitsky, University of Wollongong
                    Skye Bender-deMoll
                    Martina Morris, University of Washington
Based on "statnet" project software (statnet.org).
For license and citation information see statnet.org/attribution
or type citation("statnet").

> library(snow)
> library(rlecuyer)
> library(Rmpi)

Attaching package: ‘Rmpi’

The following object is masked from ‘package:rlecuyer’:

    .onUnload

> #setwd('H:/passtosim')
> #setwd("//Users/TScott/Google Drive/elwha")
> #setwd('H:/elwha/Dissert_Scripts/')
> 
> setwd('/homes/tscott1/win/user/elwha/PSJ_Submission/Version3/experimental/')
> load('NetworkReady.RData')
> #load('Ready_to_ERGM.RData')
> g <- sum(net %e% "TVAL")/network.dyadcount(net)
> init.geo<-log(1 - 1/(g+1))
> geo.init = init.geo
> 
> as.mcmc.default <- coda:::as.mcmc.default
> as.mcmc.list.default <- coda:::as.mcmc.list.default
> 
> dpx <- dppsp * dpn
> spx <- sppsp * spn
> spn7 <- spn/7
> spx7 <- spx/7
> sppsp7 <- sppsp/7
> dpn7 <- dpn/7
> dpx7 <- dpx/7
> dppsp7 <- dppsp/7
> ipn_pt<-get.vertex.attribute(net,'IPn7')*as.sociomatrix(net,"PRIOR_TIE")
> ippsp_pt<-get.vertex.attribute(net,'IPpsp7')*as.sociomatrix(net,"PRIOR_TIE")
> ipx_pt<-get.vertex.attribute(net,'IPx7')*as.sociomatrix(net,"PRIOR_TIE")
> dpn_pt<-dpn7*as.sociomatrix(net,"PRIOR_TIE")
> dppsp_pt<-dppsp7*as.sociomatrix(net,"PRIOR_TIE")
> dpx_pt<-dpx7*as.sociomatrix(net,"PRIOR_TIE")
> spn_pt<-spn7*as.sociomatrix(net,"PRIOR_TIE")
> sppsp_pt<-sppsp7*as.sociomatrix(net,"PRIOR_TIE")
> spx_pt<-spx7*as.sociomatrix(net,"PRIOR_TIE")
> all_sp_quad<-((spn7+sppsp7)^2)
> all_sp_pt<-((spn7+sppsp7)*as.sociomatrix(net,"PRIOR_TIE"))
> all_sp<-(spn7+sppsp7)
> central.actors = c('Federal_Agency','State_Agency','Regional_Commission')
> set.vertex.attribute(net,attrname = 'Central',
+                      value = ifelse(get.vertex.attribute(net,'ORGTYPE') %in% central.actors,1,0))
> 
> 
> 
> 
> form_unrestricted = net~sum+
+   mutual(form="nabsdiff")+
+   transitiveweights(twopath="min",combine="max",affect="min")+
+   nodecov("NUMRESP",form='sum')+
+   nodecov("NUMGROUPS",form='sum')+
+   nodecov("MEANYEARS",form='sum')+
+   nodefactor('Central')
> 
> # 
> # form3 = net~sum+
> #   mutual(form="min")+
> #   transitiveweights(twopath="min",combine="max",affect="min")+
> #   cyclicalweights(twopath="min",combine="max",affect="min") + 
> #  nodesqrtcovar(TRUE)
> #   
> # form4 = net~sum+
> #   mutual(form="min")+
> #   transitiveweights(twopath="min",combine="max",affect="min")+
> #   cyclicalweights(twopath="min",combine="max",affect="min")+
> #   nodesqrtcovar(TRUE)
> # 
> # form5 = net~sum+
> #   mutual(form="min")+
> #   transitiveweights(twopath="min",combine="max",affect="min")+
> #   nodesqrtcovar(TRUE)
> # 
> # form6 = net~sum+
> #   mutual(form="min")+
> #   transitiveweights(twopath="min",combine="max",affect="min")+
> #   cyclicalweights(twopath="min",combine="max",affect="min")+
> #   nodesqrtcovar(TRUE)+
> # nodecov("NUMRESP",form='sum')+
> #   nodecov("NUMGROUPS",form='sum')+
> #   nodecov("MEANYEARS",form='sum')
> # 
> # form7 = net~sum+
> #   mutual(form="min")+
> #   transitiveweights(twopath="min",combine="max",affect="min")+
> #   cyclicalweights(twopath="min",combine="max",affect="min")+
> #   nodesqrtcovar(TRUE)+
> #   nodecov("NUMRESP",form='sum')+
> #   nodecov("NUMGROUPS",form='sum')+
> #   nodecov("MEANYEARS",form='sum')+
> # nodefactor('Central')
> # 
> # form8 = net~sum(pow=.5)+
> #   mutual(form="min")+
> #   transitiveweights(twopath="min",combine="max",affect="min")+
> #   nodesqrtcovar(TRUE)
> # 
> # form9 = net~sum(pow=.5)+
> #   mutual(form="min")+
> #   transitiveweights(twopath="min",combine="max",affect="min")
> 
> # npar1 = length(summary(form1,response='TVAL'))-1
> # npar2 = length(summary(form2,response='TVAL'))-1
> # npar3 = length(summary(form3,response='TVAL'))-1
> # npar4 = length(summary(form4,response='TVAL'))-1
> # npar5 = length(summary(form5,response='TVAL'))-1
> # npar6 = length(summary(form6,response='TVAL'))-1
> # npar7 = length(summary(form7,response='TVAL'))-1
> # npar8 = length(summary(form8,response='TVAL'))-1
> # npar9 = length(summary(form9,response='TVAL'))-1
> 
> npar = length(summary(form_unrestricted,response='TVAL'))-1
> 
> 
> mod_ur <-
+   ergm(form_unrestricted,
+        response="TVAL", reference=~DiscUnif(0,3),
+        control=control.ergm(init=c(geo.init, rep(0, npar)),
+                             MCMLE.maxit=30,MCMC.runtime.traceplot=F,seed=24,
+                             MCMLE.trustregion=1000,MCMC.addto.se=T,
+                             parallel.type="SOCK",parallel=8,
+                             MPLE.max.dyad.types=1e+7,MCMC.samplesize=50000,
+                             MCMC.burnin=15000,MCMC.interval=1500,
+                             MCMLE.steplength=.25,
+                             MCMC.prop.args=list(p0=0.5)),eval.loglik=F,verbose=T)
Evaluating network in model
Initializing Metropolis-Hastings proposal(s): ergm:MH_DiscUnif
Initializing model.
Fitting initial model.
Fitting ERGM.
Density guard set to 20989 from an initial count of 1045  edges.
Iteration 1 of at most 30 with parameter: 
                          sum               mutual.nabsdiff 
                    -3.091141                      0.000000 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                     0.000000                      0.000000 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                     0.000000                      0.000000 
     nodefactor.sum.Central.1 
                     0.000000 
Using SOCK.
Sample size = 50000 by 6250 
Back from unconstrained MCMC. Average statistics:
                          sum               mutual.nabsdiff 
                     -7.95148                    -527.20044 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                   -620.02808                   -7573.97296 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    -75.15851                   -6345.78547 
     nodefactor.sum.Central.1 
                   -579.39534 
Average estimating equation values:
                          sum               mutual.nabsdiff 
                     -7.95148                    -527.20044 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                   -620.02808                   -7573.97296 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    -75.15851                   -6345.78547 
     nodefactor.sum.Central.1 
                   -579.39534 
Calling MCMLE Optimization...
Using Newton-Raphson Step with step length  0.25  ...
Using lognormal metric (see control.ergm function).
Optimizing loglikelihood
Starting MCMC s.e. computation.
The log-likelihood improved by 23.02 
Step length converged once. Increasing MCMC sample size.
Iteration 2 of at most 30 with parameter: 
                          sum               mutual.nabsdiff 
                -2.972628e+00                  2.042389e-01 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                 1.100922e-01                  6.815191e-04 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                 5.240395e-04                  5.392015e-05 
     nodefactor.sum.Central.1 
                 3.010608e-03 
Using SOCK.
Sample size = 200000 by 25000 
Back from unconstrained MCMC. Average statistics:
                          sum               mutual.nabsdiff 
                     118.5440                     -595.0089 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -432.4771                    -7174.3352 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    1033.3759                    -4137.3044 
     nodefactor.sum.Central.1 
                    -555.8064 
Average estimating equation values:
                          sum               mutual.nabsdiff 
                     118.5440                     -595.0089 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -432.4771                    -7174.3352 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    1033.3759                    -4137.3044 
     nodefactor.sum.Central.1 
                    -555.8064 
Calling MCMLE Optimization...
Using Newton-Raphson Step with step length  0.0483448803424836  ...
Using lognormal metric (see control.ergm function).
Optimizing loglikelihood
Starting MCMC s.e. computation.
The log-likelihood improved by 6.197 
Iteration 3 of at most 30 with parameter: 
                          sum               mutual.nabsdiff 
                -3.0254810638                  0.2913156507 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                 0.1457898893                  0.0232331477 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                 0.0003020941                  0.0003072679 
     nodefactor.sum.Central.1 
                 0.0386318784 
Using SOCK.
Sample size = 50000 by 6250 
Back from unconstrained MCMC. Average statistics:
                          sum               mutual.nabsdiff 
                     121.5097                     -568.9727 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -396.4236                    -6728.9596 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    1107.5698                    -3792.7449 
     nodefactor.sum.Central.1 
                    -522.5712 
Average estimating equation values:
                          sum               mutual.nabsdiff 
                     121.5097                     -568.9727 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -396.4236                    -6728.9596 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    1107.5698                    -3792.7449 
     nodefactor.sum.Central.1 
                    -522.5712 
Calling MCMLE Optimization...
Using Newton-Raphson Step with step length  0.0558555126190186  ...
Using lognormal metric (see control.ergm function).
Optimizing loglikelihood
Starting MCMC s.e. computation.
The log-likelihood improved by 4.249 
Iteration 4 of at most 30 with parameter: 
                          sum               mutual.nabsdiff 
                -3.058062e+00                  3.529789e-01 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                 1.745495e-01                  3.587889e-02 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                 9.615226e-06                  5.342699e-04 
     nodefactor.sum.Central.1 
                 6.812286e-02 
Using SOCK.
Sample size = 50000 by 6250 
Back from unconstrained MCMC. Average statistics:
                          sum               mutual.nabsdiff 
                     121.3988                     -544.0222 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -364.8032                    -6392.7339 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    1097.8446                    -3472.0939 
     nodefactor.sum.Central.1 
                    -490.7590 
Average estimating equation values:
                          sum               mutual.nabsdiff 
                     121.3988                     -544.0222 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -364.8032                    -6392.7339 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    1097.8446                    -3472.0939 
     nodefactor.sum.Central.1 
                    -490.7590 
Calling MCMLE Optimization...
Using Newton-Raphson Step with step length  0.0611132383346558  ...
Using lognormal metric (see control.ergm function).
Optimizing loglikelihood
Starting MCMC s.e. computation.
The log-likelihood improved by 5.208 
Iteration 5 of at most 30 with parameter: 
                          sum               mutual.nabsdiff 
                -3.1049842721                  0.4187365525 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                 0.1854885412                  0.0525842775 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                 0.0005745288                  0.0012741691 
     nodefactor.sum.Central.1 
                 0.1012244500 
Using SOCK.
Sample size = 50000 by 6250 
Back from unconstrained MCMC. Average statistics:
                          sum               mutual.nabsdiff 
                     141.1469                     -530.7846 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -310.8712                    -5743.2987 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    1341.2342                    -2551.5649 
     nodefactor.sum.Central.1 
                    -442.0917 
Average estimating equation values:
                          sum               mutual.nabsdiff 
                     141.1469                     -530.7846 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -310.8712                    -5743.2987 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    1341.2342                    -2551.5649 
     nodefactor.sum.Central.1 
                    -442.0917 
Calling MCMLE Optimization...
Using Newton-Raphson Step with step length  0.096536934375763  ...
Using lognormal metric (see control.ergm function).
Optimizing loglikelihood
Starting MCMC s.e. computation.
The log-likelihood improved by 6.368 
Iteration 6 of at most 30 with parameter: 
                          sum               mutual.nabsdiff 
                -3.1214583063                  0.4902235347 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                 0.2003190421                  0.0663624616 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                -0.0006468553                  0.0016354826 
     nodefactor.sum.Central.1 
                 0.1133360320 
Using SOCK.
Sample size = 50000 by 6250 
Back from unconstrained MCMC. Average statistics:
                          sum               mutual.nabsdiff 
                     145.5393                     -493.1372 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -264.2429                    -5168.1478 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    1316.3333                    -2087.1036 
     nodefactor.sum.Central.1 
                    -404.2229 
Average estimating equation values:
                          sum               mutual.nabsdiff 
                     145.5393                     -493.1372 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -264.2429                    -5168.1478 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    1316.3333                    -2087.1036 
     nodefactor.sum.Central.1 
                    -404.2229 
Calling MCMLE Optimization...
Using Newton-Raphson Step with step length  0.0897095501422882  ...
Using lognormal metric (see control.ergm function).
Optimizing loglikelihood
Starting MCMC s.e. computation.
The log-likelihood improved by 4.237 
Iteration 7 of at most 30 with parameter: 
                          sum               mutual.nabsdiff 
                 -3.116972004                   0.548310104 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                  0.199600336                   0.076790533 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                 -0.002821766                   0.001859223 
     nodefactor.sum.Central.1 
                  0.136677069 
Using SOCK.
Sample size = 50000 by 6250 
Back from unconstrained MCMC. Average statistics:
                          sum               mutual.nabsdiff 
                     135.6080                     -446.4688 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -233.1255                    -4658.1382 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    1178.2758                    -1785.1111 
     nodefactor.sum.Central.1 
                    -362.5261 
Average estimating equation values:
                          sum               mutual.nabsdiff 
                     135.6080                     -446.4688 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -233.1255                    -4658.1382 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    1178.2758                    -1785.1111 
     nodefactor.sum.Central.1 
                    -362.5261 
Calling MCMLE Optimization...
Using Newton-Raphson Step with step length  0.122898608446121  ...
Using lognormal metric (see control.ergm function).
Optimizing loglikelihood
Starting MCMC s.e. computation.
The log-likelihood improved by 4.588 
Iteration 8 of at most 30 with parameter: 
                          sum               mutual.nabsdiff 
                 -3.130492669                   0.594537631 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                  0.193607080                   0.086839351 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                 -0.004041162                   0.002493093 
     nodefactor.sum.Central.1 
                  0.148276961 
Using SOCK.
Sample size = 50000 by 6250 
Back from unconstrained MCMC. Average statistics:
                          sum               mutual.nabsdiff 
                     133.4765                     -405.0751 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -195.4019                    -4057.4812 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    1153.8842                    -1299.5888 
     nodefactor.sum.Central.1 
                    -321.3400 
Average estimating equation values:
                          sum               mutual.nabsdiff 
                     133.4765                     -405.0751 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -195.4019                    -4057.4812 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    1153.8842                    -1299.5888 
     nodefactor.sum.Central.1 
                    -321.3400 
Calling MCMLE Optimization...
Using Newton-Raphson Step with step length  0.134653270244598  ...
Using lognormal metric (see control.ergm function).
Optimizing loglikelihood
Starting MCMC s.e. computation.
The log-likelihood improved by 4.352 
Iteration 9 of at most 30 with parameter: 
                          sum               mutual.nabsdiff 
                 -3.150646829                   0.637716338 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                  0.185102651                   0.095806151 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                 -0.003179541                   0.002387471 
     nodefactor.sum.Central.1 
                  0.182116991 
Using SOCK.
Sample size = 50000 by 6250 
Back from unconstrained MCMC. Average statistics:
                          sum               mutual.nabsdiff 
                     138.4683                     -366.7661 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -138.8795                    -3353.1133 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    1268.9666                     -655.7498 
     nodefactor.sum.Central.1 
                    -261.4618 
Average estimating equation values:
                          sum               mutual.nabsdiff 
                     138.4683                     -366.7661 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -138.8795                    -3353.1133 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    1268.9666                     -655.7498 
     nodefactor.sum.Central.1 
                    -261.4618 
Calling MCMLE Optimization...
Using Newton-Raphson Step with step length  0.174852132797241  ...
Using lognormal metric (see control.ergm function).
Optimizing loglikelihood
Starting MCMC s.e. computation.
The log-likelihood improved by 4.345 
Iteration 10 of at most 30 with parameter: 
                          sum               mutual.nabsdiff 
                 -3.172023202                   0.679878117 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                  0.171265421                   0.104284429 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                 -0.002708379                   0.002395262 
     nodefactor.sum.Central.1 
                  0.202644796 
Using SOCK.
Sample size = 50000 by 6250 
Back from unconstrained MCMC. Average statistics:
                          sum               mutual.nabsdiff 
                     119.3006                     -307.7039 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -109.1288                    -2761.0888 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    1144.9046                     -516.2636 
     nodefactor.sum.Central.1 
                    -213.4721 
Average estimating equation values:
                          sum               mutual.nabsdiff 
                     119.3006                     -307.7039 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -109.1288                    -2761.0888 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    1144.9046                     -516.2636 
     nodefactor.sum.Central.1 
                    -213.4721 
Calling MCMLE Optimization...
Using Newton-Raphson Step with step length  0.231604814529419  ...
Using lognormal metric (see control.ergm function).
Optimizing loglikelihood
Starting MCMC s.e. computation.
The log-likelihood improved by 5.329 
Iteration 11 of at most 30 with parameter: 
                          sum               mutual.nabsdiff 
                 -3.175229492                   0.731398381 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                  0.154018410                   0.112999754 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                 -0.004384226                   0.002608901 
     nodefactor.sum.Central.1 
                  0.228735452 
Using SOCK.
Sample size = 50000 by 6250 
Back from unconstrained MCMC. Average statistics:
                          sum               mutual.nabsdiff 
                     92.94096                    -234.25664 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -81.64436                   -2141.48074 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    861.63386                    -470.04805 
     nodefactor.sum.Central.1 
                   -156.82230 
Average estimating equation values:
                          sum               mutual.nabsdiff 
                     92.94096                    -234.25664 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -81.64436                   -2141.48074 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    861.63386                    -470.04805 
     nodefactor.sum.Central.1 
                   -156.82230 
Calling MCMLE Optimization...
Using Newton-Raphson Step with step length  0.25  ...
Using lognormal metric (see control.ergm function).
Optimizing loglikelihood
Starting MCMC s.e. computation.
The log-likelihood improved by 3.58 
Step length converged once. Increasing MCMC sample size.
Iteration 12 of at most 30 with parameter: 
                          sum               mutual.nabsdiff 
                 -3.194209499                   0.759282888 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                  0.130825672                   0.121664411 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                 -0.006251589                   0.003089562 
     nodefactor.sum.Central.1 
                  0.240531409 
Using SOCK.
Sample size = 200000 by 25000 
Back from unconstrained MCMC. Average statistics:
                          sum               mutual.nabsdiff 
                     60.97315                    -168.81543 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -74.45760                   -1607.42888 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    554.45338                    -488.84084 
     nodefactor.sum.Central.1 
                   -122.69930 
Average estimating equation values:
                          sum               mutual.nabsdiff 
                     60.97315                    -168.81543 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -74.45760                   -1607.42888 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    554.45338                    -488.84084 
     nodefactor.sum.Central.1 
                   -122.69930 
Calling MCMLE Optimization...
Using Newton-Raphson Step with step length  0.25  ...
Using lognormal metric (see control.ergm function).
Optimizing loglikelihood
Starting MCMC s.e. computation.
The log-likelihood improved by 1.802 
Step length converged twice. Stopping.

This model was fit using MCMC.  To examine model diagnostics and check for degeneracy, use the mcmc.diagnostics() function.
Warning message:
In logLikNull.ergm(mainfit) :
  Null model likelihood calculation is not implemented for valued ERGMs at this time.
> 
> save.image('results_unrestricted_parallel.RData')
> # 
> # mod2 <-
> #   ergm(form2,
> #        response="TVAL", reference=~DiscUnif(0,3),
> #        control=control.ergm(init=c(geo.init, rep(0, npar2)),
> #                             MCMLE.maxit=30,MCMC.runtime.traceplot=F,seed=24,
> #                             MCMLE.trustregion=1000,MCMC.addto.se=T,
> #                             #  parallel.type="SOCK",parallel=8,
> #                             MPLE.max.dyad.types=1e+7,MCMC.samplesize=10000,
> #                             MCMC.burnin=10000,MCMC.interval=1000,
> #                             MCMLE.steplength=.25,
> #                             MCMC.prop.args=list(p0=0.5)),eval.loglik=F,verbose=T)
> # 
> # save.image('results_modtesting.RData')
> # 
> # mod3 <-
> #   ergm(form3,
> #        response="TVAL", reference=~DiscUnif(0,3),
> #        control=control.ergm(init=c(geo.init, rep(0, npar3)),
> #                             MCMLE.maxit=30,MCMC.runtime.traceplot=F,seed=24,
> #                             MCMLE.trustregion=1000,MCMC.addto.se=T,
> #                             #  parallel.type="SOCK",parallel=8,
> #                             MPLE.max.dyad.types=1e+7,MCMC.samplesize=10000,
> #                             MCMC.burnin=10000,MCMC.interval=1000,
> #                             MCMLE.steplength=.25,
> #                             MCMC.prop.args=list(p0=0.5)),eval.loglik=F,verbose=T)
> # 
> # save.image('results_modtesting.RData')
> # 
> # mod4 <-
> #   ergm(form4,
> #        response="TVAL", reference=~DiscUnif(0,3),
> #        control=control.ergm(init=c(geo.init, rep(0, npar4)),
> #                             MCMLE.maxit=30,MCMC.runtime.traceplot=F,seed=24,
> #                             MCMLE.trustregion=1000,MCMC.addto.se=T,
> #                             #  parallel.type="SOCK",parallel=8,
> #                             MPLE.max.dyad.types=1e+7,MCMC.samplesize=10000,
> #                             MCMC.burnin=10000,MCMC.interval=1000,
> #                             MCMLE.steplength=.25,
> #                             MCMC.prop.args=list(p0=0.5)),eval.loglik=F,verbose=T)
> # 
> # save.image('results_modtesting.RData')
> # mod5 <-
> #   ergm(form5,
> #        response="TVAL", reference=~DiscUnif(0,3),
> #        control=control.ergm(init=c(geo.init, rep(0, npar5)),
> #                             MCMLE.maxit=30,MCMC.runtime.traceplot=F,seed=24,
> #                             MCMLE.trustregion=1000,MCMC.addto.se=T,
> #                             #  parallel.type="SOCK",parallel=8,
> #                             MPLE.max.dyad.types=1e+7,MCMC.samplesize=10000,
> #                             MCMC.burnin=10000,MCMC.interval=1000,
> #                             MCMLE.steplength=.25,
> #                             MCMC.prop.args=list(p0=0.5)),eval.loglik=F,verbose=T)
> # 
> # mod6 <-
> #   ergm(form6,
> #        response="TVAL", reference=~DiscUnif(0,3),
> #        control=control.ergm(init=c(geo.init, rep(0, npar6)),
> #                             MCMLE.maxit=30,MCMC.runtime.traceplot=F,seed=24,
> #                             MCMLE.trustregion=1000,MCMC.addto.se=T,
> #                             #  parallel.type="SOCK",parallel=8,
> #                             MPLE.max.dyad.types=1e+7,MCMC.samplesize=10000,
> #                             MCMC.burnin=10000,MCMC.interval=1000,
> #                             MCMLE.steplength=.25,
> #                             MCMC.prop.args=list(p0=0.5)),eval.loglik=F,verbose=T)
> # 
> # mod7 <-
> #   ergm(form7,
> #        response="TVAL", reference=~DiscUnif(0,3),
> #        control=control.ergm(init=c(geo.init, rep(0, npar7)),
> #                             MCMLE.maxit=30,MCMC.runtime.traceplot=F,seed=24,
> #                             MCMLE.trustregion=1000,MCMC.addto.se=T,
> #                             #  parallel.type="SOCK",parallel=8,
> #                             MPLE.max.dyad.types=1e+7,MCMC.samplesize=10000,
> #                             MCMC.burnin=10000,MCMC.interval=1000,
> #                             MCMLE.steplength=.25,
> #                             MCMC.prop.args=list(p0=0.5)),eval.loglik=F,verbose=T)
> # 
> # mod8 <-
> #   ergm(form8,
> #        response="TVAL", reference=~DiscUnif(0,3),
> #        control=control.ergm(init=c(geo.init, rep(0, npar8)),
> #                             MCMLE.maxit=30,MCMC.runtime.traceplot=F,seed=24,
> #                             MCMLE.trustregion=1000,MCMC.addto.se=T,
> #                             #  parallel.type="SOCK",parallel=8,
> #                             MPLE.max.dyad.types=1e+7,MCMC.samplesize=10000,
> #                             MCMC.burnin=10000,MCMC.interval=1000,
> #                             MCMLE.steplength=.25,
> #                             MCMC.prop.args=list(p0=0.5)),eval.loglik=F,verbose=T)
> # 
> # mod9 <-
> #   ergm(form9,
> #        response="TVAL", reference=~DiscUnif(0,3),
> #        control=control.ergm(init=c(geo.init, rep(0, npar9)),
> #                             MCMLE.maxit=30,MCMC.runtime.traceplot=F,seed=24,
> #                             MCMLE.trustregion=1000,MCMC.addto.se=T,
> #                             #  parallel.type="SOCK",parallel=8,
> #                             MPLE.max.dyad.types=1e+7,MCMC.samplesize=10000,
> #                             MCMC.burnin=10000,MCMC.interval=1000,
> #                             MCMLE.steplength=.25,
> #                             MCMC.prop.args=list(p0=0.5)),eval.loglik=F,verbose=T)
> 
> 
> 
> # 
> # npar = length(summary(form,response='TVAL'))-1
> # 
> # mod_base <-
> #   ergm(form,
> #        response="TVAL", reference=~DiscUnif(0,3),
> #        control=control.ergm(init=c(geo.init, rep(0, npar)),
> #                             MCMLE.maxit=30,MCMC.runtime.traceplot=F,seed=24,
> #                             MCMLE.trustregion=1000,MCMC.addto.se=T,
> #                             parallel.type="SOCK",parallel=8,
> #                             MPLE.max.dyad.types=1e+7,MCMC.samplesize=50000,
> #                             MCMC.burnin=15000,MCMC.interval=1500,MCMLE.steplength=.25,
> #                             MCMC.prop.args=list(p0=0.5)),eval.loglik=F,verbose=T)
> # 
> 
> 
> 
> # mod_indpart3<-
> #   ergm(net~sum+mutual(form="min")+
> #          transitiveweights("min","max","min")+nodecov("NUMRESP")+
> #          nodecov("NUMGROUPS")+nodecov("MEANYEARS")+nodematch("ORGTYPE",form='sum')+
> #          nodecov('IPn7')+nodecov('IPpsp7')+nodecov('IPx7'),
> #        response="TVAL", reference=~DiscUnif(0,3),
> #        control=control.ergm(init=c(geo.init, rep(0, 9)),
> #                             MCMLE.maxit=30,MCMC.runtime.traceplot=F,seed=24,
> #                             MCMLE.trustregion=1000,MCMC.addto.se=T,parallel.type="SOCK",
> #                             MPLE.max.dyad.types=1e+7,parallel=4,MCMC.samplesize=16000,
> #                             MCMC.burnin=10000,MCMC.interval=1000,MCMLE.steplength=.25,
> #                             MCMC.prop.args=list(p0=0.5)),eval.loglik=F)
> # 
> # mod_indpart<-mod_indpart3
> # 
> # mod_dirpart <-
> #     ergm(net~sum+mutual(form="min")+
> # transitiveweights("min","max","min")+nodecov("NUMRESP")+
> # nodecov("NUMGROUPS")+nodecov("MEANYEARS")+nodematch("ORGTYPE")+
> # edgecov(dpn7,form='sum')+edgecov(dppsp7,form='sum')+edgecov(dpx7,form='sum'),
> #          response="TVAL", reference=~DiscUnif(0,3),
> #          control=control.ergm(init=c(geo.init, rep(0, 9)),
> #                               MCMLE.maxit=30,MCMC.runtime.traceplot=F,seed=24,
> #                               MCMLE.trustregion=1000,MCMC.addto.se=T,
> #                               parallel.type="MPI",parallel=8,
> #                               MPLE.max.dyad.types=1e+7,MCMC.samplesize=50000,
> #                               MCMC.burnin=15000,MCMC.interval=1500,MCMLE.steplength=.25,
> #                               MCMC.prop.args=list(p0=0.5)),eval.loglik=F)
> # 
> # mod_shapart <-
> #   ergm(net~sum+mutual(form="min")+
> #          transitiveweights("min","max","min")+nodecov("NUMRESP")+
> #          nodecov("NUMGROUPS")+nodecov("MEANYEARS")+nodematch("ORGTYPE",form='sum')+
> #          edgecov(spn7,form='sum')+edgecov(sppsp7,form='sum')+edgecov(spx7,form='sum'),
> #        response="TVAL", reference=~DiscUnif(0,3),
> #        control=control.ergm(init=c(geo.init, rep(0, 9)),
> #                             MCMLE.maxit=30,MCMC.runtime.traceplot=F,seed=24,
> #                             MCMLE.trustregion=1000,MCMC.addto.se=T,
> #                             parallel.type="MPI",parallel=8,
> #                             MPLE.max.dyad.types=1e+7,MCMC.samplesize=50000,
> #                             MCMC.burnin=15000,MCMC.interval=1500,MCMLE.steplength=.25,
> #                             MCMC.prop.args=list(p0=0.5)),eval.loglik=F)
> # 
> # detach(file:NetworkReady.RData)
> # 
> # rm(
> # list=ls()[intersect(grep('shapart',ls(),invert=T),grep('dirpart',ls(),
> #                                                        invert=T))])
> 
> rm(list=ls())
> 
