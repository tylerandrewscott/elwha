
R version 3.2.0 (2015-04-16) -- "Full of Ingredients"
Copyright (C) 2015 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> rm(list=ls())
> #install.packages('statnet',dependencies=TRUE,repos='http://cran.us.r-project.org')
> #setwd("win/user/elwha/data_files/")
> require(statnet)
Loading required package: statnet
Loading required package: network
network: Classes for Relational Data
Version 1.12.0 created on 2015-03-04.
copyright (c) 2005, Carter T. Butts, University of California-Irvine
                    Mark S. Handcock, University of California -- Los Angeles
                    David R. Hunter, Penn State University
                    Martina Morris, University of Washington
                    Skye Bender-deMoll, University of Washington
 For citation information, type citation("network").
 Type help("network-package") to get started.

Loading required package: ergm
Loading required package: statnet.common

ergm: version 3.2.4, created on 2014-12-13
Copyright (c) 2014, Mark S. Handcock, University of California -- Los Angeles
                    David R. Hunter, Penn State University
                    Carter T. Butts, University of California -- Irvine
                    Steven M. Goodreau, University of Washington
                    Pavel N. Krivitsky, University of Wollongong
                    Martina Morris, University of Washington
                    with contributions from
                    Li Wang
                    Kirk Li, University of Washington
Based on "statnet" project software (statnet.org).
For license and citation information see statnet.org/attribution
or type citation("ergm").

NOTE: If you use custom ERGM terms based on ‘ergm.userterms’ version
prior to 3.1, you will need to perform a one-time update of the package
boilerplate files (the files that you did not write or modify) from
‘ergm.userterms’ 3.1 or later. See help('eut-upgrade') for
instructions.

Loading required package: sna
sna: Tools for Social Network Analysis
Version 2.3-2 created on 2014-01-13.
copyright (c) 2005, Carter T. Butts, University of California-Irvine
 For citation information, type citation("sna").
 Type help(package="sna") to get started.


Attaching package: ‘sna’

The following object is masked from ‘package:network’:

    %c%

Loading required package: networkDynamic

networkDynamic: version 0.7.1, created on 2014-09-29
Copyright (c) 2014, Carter T. Butts, University of California -- Irvine
                    Ayn Leslie-Cook, University of Washington
                    Pavel N. Krivitsky, University of Wollongong
                    Skye Bender-deMoll, University of Washington
                    with contributions from
                    Zack Almquist, University of California -- Irvine
                    David R. Hunter, Penn State University
                    Li Wang
                    Kirk Li, University of Washington
                    Steven M. Goodreau, University of Washington
                    Jeffrey Horner
                    Martina Morris, University of Washington
Based on "statnet" project software (statnet.org).
For license and citation information see statnet.org/attribution
or type citation("networkDynamic").

Loading required package: tergm

tergm: version 3.2.4, created on 2014-12-13
Copyright (c) 2014, Pavel N. Krivitsky, University of Wollongong
                    Mark S. Handcock, University of California -- Los Angeles
                    with contributions from
                    David R. Hunter, Penn State University
                    Steven M. Goodreau, University of Washington
                    Martina Morris, University of Washington
                    Nicole Bohme Carnegie, New York University
                    Carter T. Butts, University of California -- Irvine
                    Ayn Leslie-Cook, University of Washington
                    Skye Bender-deMoll
                    Li Wang
                    Kirk Li, University of Washington
Based on "statnet" project software (statnet.org).
For license and citation information see statnet.org/attribution
or type citation("tergm").

Loading required package: ergm.count

ergm.count: version 3.1.1, created on 2013-03-29
Copyright (c) 2013, Pavel N. Krivitsky, University of Wollongong
                    with contributions from
                    Mark S. Handcock, University of California -- Los Angeles
                    David R. Hunter, Penn State University
Based on "statnet" project software (statnet.org).
For license and citation information see statnet.org/attribution
or type citation("ergm.count").

Loading required package: latentnet

latentnet: version 2.7.0, created on 2015-03-21
Copyright (c) 2015, Pavel N. Krivitsky, University of Wollongong
                    Mark S. Handcock, University of California -- Los Angeles
                    with contributions from
                    Susan M. Shortreed
                    Jeremy Tantrum
                    Peter D. Hoff
                    Li Wang
                    Kirk Li, University of Washington
Based on "statnet" project software (statnet.org).
For license and citation information see statnet.org/attribution
or type citation("latentnet").
NOTE: BIC calculation prior latentnet 2.7.0 had a bug in the calculation of the effective number of parameters. See help(summary.ergmm) for details.

statnet: version 2014.2.0, created on 2014-02-05
Copyright (c) 2014, Mark S. Handcock, University of California -- Los Angeles
                    David R. Hunter, Penn State University
                    Carter T. Butts, University of California -- Irvine
                    Steven M. Goodreau, University of Washington
                    Pavel N. Krivitsky, University of Wollongong
                    Skye Bender-deMoll
                    Martina Morris, University of Washington
Based on "statnet" project software (statnet.org).
For license and citation information see statnet.org/attribution
or type citation("statnet").

> library(RCurl)
Loading required package: bitops
> library(readr)
> library(ergm)
> 
> 
> library(RCurl)
> dat_all <- read.csv(text = getURL("https://raw.githubusercontent.com/tylerascott/elwha/master/data_files/edgelist_all.csv"),row.names=1)
> 
> # Read a csv file into a data frame
> 
> #dat_all=read.csv(file="edgelist_all.csv",row.names=1)
> temp<-dat_all[as.character(dat_all$ORG)!=as.character(dat_all$Contact),]
> 
> temp$paste<-paste(temp$ORG,temp$Contact)
> 
> temptab<-data.frame(table(temp$paste))
> colnames(temptab) = c('paste','Freq')
> 
> temp$count = temptab$Freq[match(temp$paste,temptab$paste)]
> 
> t<-temp[order(temp$TType,decreasing=T),]
> 
> tt<-t[!duplicated(t$paste),]
> 
> resp.dat=read.csv(text = getURL('https://raw.githubusercontent.com/tylerascott/elwha/master/data_files/Response.Used.csv')
+    ,row.names=1)
>                            
> 
> allorgs<-sort(unique(c(as.character(resp.dat$ORG),as.character(tt$ORG),as.character(tt$Contact))))
> 
> tt$INSURV<-tt$Contact %in% resp.dat$ORG
> 
> t1<-tt[tt$INSURV==TRUE,]
> 
> net_temp = network.initialize(length(unique(resp.dat$ORG)),directed=TRUE,loops=FALSE)
> vertex_attributes  = data.frame(sort(unique(resp.dat$ORG)))
> colnames(vertex_attributes) = "NAME"
> network.vertex.names(net_temp)<-as.character(vertex_attributes$NAME)
> 
> TAIL_ID = match(t1$ORG,network.vertex.names(net_temp))
> HEAD_ID = match(t1$Contact,network.vertex.names(net_temp))
> 
> for (i in 1:length(TAIL_ID))
+ {
+   net_temp[TAIL_ID[i],HEAD_ID[i]]<-1
+   net_temp[TAIL_ID[i],HEAD_ID[i],"TCO"]<-t1$count[i]
+   net_temp[TAIL_ID[i],HEAD_ID[i],"TVAL"]<-ifelse(t1$TType[i]=="WT",
+                                                  3,ifelse(t1$TType[i]=="PT",2,1))
+   net_temp[TAIL_ID[i],HEAD_ID[i],"WIN5_dk1"]<-ifelse(is.na(t1$WIN5[i]),1,(ifelse(t1$WIN5[i]>0,1,t1$WIN5)))
+   net_temp[TAIL_ID[i],HEAD_ID[i],"WIN5_dk0"]<-ifelse(is.na(t1$WIN5[i]),0,(ifelse(t1$WIN5[i]==1,1,0)))
+   net_temp[TAIL_ID[i],HEAD_ID[i],"PRIOR_TIE"]<-ifelse(is.na(t1$WIN5[i]),0,(ifelse(t1$WIN5[i]>0,0,1)))
+ }
> 
> 
> vertex_attributes$TOTALYEARS = resp.dat$total.years[match(vertex_attributes$NAME,resp.dat$ORG)]
> 
> 
> library(plyr)

Attaching package: ‘plyr’

The following object is masked from ‘package:network’:

    is.discrete

> library(dplyr)

Attaching package: ‘dplyr’

The following objects are masked from ‘package:plyr’:

    arrange, count, desc, failwith, id, mutate, rename, summarise,
    summarize

The following object is masked from ‘package:stats’:

    filter

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> vertex_attributes$NUMGROUPS = data.frame(resp.dat %>% group_by(ORG) %>% summarise(mean(NumGroups)))[,2][
+   match(vertex_attributes$NAME, data.frame(resp.dat %>% group_by(ORG) %>% summarise(mean(NumGroups)))[,1])]
> 
> vertex_attributes$NUMRESP = data.frame(resp.dat %>% group_by(ORG) %>% summarise(mean(Numres)))[,2][
+   match(vertex_attributes$NAME, data.frame(resp.dat %>% group_by(ORG) %>% summarise(mean(Numres)))[,1])]
> 
> vertex_attributes$MEANYEARS= data.frame(resp.dat %>% group_by(ORG) %>% summarise(mean(Years)))[,2][
+   match(vertex_attributes$NAME, data.frame(resp.dat %>% group_by(ORG) %>% summarise(mean(Years)))[,1])]
> 
> vertex_attributes$ORGTYPE = resp.dat$ORGType[match(vertex_attributes$NAME,resp.dat$ORG)]
> 
> vertex_attributes$USEPLAN = resp.dat$useful_plan[match(vertex_attributes$NAME,resp.dat$ORG)]
> vertex_attributes$USEWORK = resp.dat$useful_work[match(vertex_attributes$NAME,resp.dat$ORG)]
> vertex_attributes$USECONS = resp.dat$useful_cons[match(vertex_attributes$NAME,resp.dat$ORG)]
> 
> 
> temp = as.data.frame(tapply(resp.dat$npsp,resp.dat$ORG,mean))
> temp$ORG = rownames(temp)
> colnames(temp)[1] = 'npsp.mean'
> resp.dat$npsp = as.vector(temp$npsp.mean[match(resp.dat$ORG,temp$ORG)])
> 
> temp = as.data.frame(tapply(resp.dat$psp,resp.dat$ORG,mean))
> temp$ORG = rownames(temp)
> colnames(temp)[1] = 'psp.mean'
> resp.dat$psp = as.vector(temp$psp.mean[match(resp.dat$ORG,temp$ORG)])
> 
> vertex_attributes$PSP_N = as.vector(
+   tapply(resp.dat$psp,resp.dat$ORG,mean)[match(vertex_attributes$NAME, rownames(tapply(resp.dat$psp,resp.dat$ORG,mean)))])
> 
> vertex_attributes$NPSP_N = as.vector(
+   tapply(resp.dat$psp,resp.dat$ORG,mean)[match(vertex_attributes$NAME, rownames(tapply(resp.dat$npsp,resp.dat$ORG,mean)))])
> 
> 
> network.vertex.names(net_temp) = as.character(vertex_attributes$NAME)
> 
> set.vertex.attribute(net_temp,"ORGTYPE",value=as.character(vertex_attributes$ORGTYPE))
> set.vertex.attribute(net_temp,"TOTALYEARS",value=vertex_attributes$TOTALYEARS)
> set.vertex.attribute(net_temp,"NUMGROUPS",value=vertex_attributes$NUMGROUPS)
> set.vertex.attribute(net_temp,"NUMRESP",value=vertex_attributes$NUMRESP)
> set.vertex.attribute(net_temp,"MEANYEARS",value=vertex_attributes$MEANYEARS)
> set.vertex.attribute(net_temp,"PSP_N",    value=vertex_attributes$PSP_N)
> set.vertex.attribute(net_temp,"NPSP_N",value=vertex_attributes$NPSP_N)
> set.vertex.attribute(net_temp,"USEWORK",value=ifelse(is.na(as.numeric(vertex_attributes$USEWORK)),0,as.numeric(vertex_attributes$USEWORK)))
> set.vertex.attribute(net_temp,"USEPLAN",value=ifelse(is.na(as.numeric(vertex_attributes$USEPLAN)),0,as.numeric(vertex_attributes$USEPLAN)))
> set.vertex.attribute(net_temp,"USECONS",value=ifelse(is.na(as.numeric(vertex_attributes$USECONS)),0,as.numeric(vertex_attributes$USECONS)))
> 
> 
> net<-net_temp
> 
> psp_group <-read.csv(text = getURL("https://raw.githubusercontent.com/tylerascott/elwha/master/data_files/Group.Overlap.Matrix.PSP.csv"),row.names=1)
> all_group <-read.csv(text = getURL("https://raw.githubusercontent.com/tylerascott/elwha/master/data_files/Group.Overlap.Matrix.csv"),row.names=1)
> npsp_group <-read.csv(text = getURL("https://raw.githubusercontent.com/tylerascott/elwha/master/data_files/Group.Overlap.Matrix.NPSP.csv"),row.names=1)
> fina_up_group<-read.csv(text = getURL("https://raw.githubusercontent.com/tylerascott/elwha/master/data_files/Group.Fina.Up.Matrix.csv"),row.names=1)
> fina_down_group<-read.csv(text = getURL("https://raw.githubusercontent.com/tylerascott/elwha/master/data_files/Group.Fina.Down.Matrix.csv"),row.names=1)
> huma_up_group<-read.csv(text = getURL("https://raw.githubusercontent.com/tylerascott/elwha/master/data_files/Group.Huma.Up.Matrix.csv"),row.names=1)
> huma_down_group<-read.csv(text = getURL("https://raw.githubusercontent.com/tylerascott/elwha/master/data_files/Group.Huma.Down.Matrix.csv"),row.names=1)
> valu_up_group<-read.csv(text = getURL("https://raw.githubusercontent.com/tylerascott/elwha/master/data_files/Group.Valu.Up.Matrix.csv"),row.names=1)
> valu_down_group<-read.csv(text = getURL("https://raw.githubusercontent.com/tylerascott/elwha/master/data_files/Group.Value.Down.Matrix.csv"),row.names=1)
> lang_up_group<-read.csv(text = getURL("https://raw.githubusercontent.com/tylerascott/elwha/master/data_files/Group.Lang.Up.Matrix.csv"),row.names=1)
> lang_down_group<-read.csv(text = getURL("https://raw.githubusercontent.com/tylerascott/elwha/master/data_files/Group.Lang.Down.Matrix.csv"),row.names=1)
> scie_up_group<-read.csv(text = getURL("https://raw.githubusercontent.com/tylerascott/elwha/master/data_files/Group.Scie.Up.Matrix.csv"),row.names=1)
> scie_down_group<-read.csv(text = getURL("https://raw.githubusercontent.com/tylerascott/elwha/master/data_files/Group.Scie.Down.Matrix.csv"),row.names=1)
> face_up_group<-read.csv(text = getURL("https://raw.githubusercontent.com/tylerascott/elwha/master/data_files/Group.Face.Up.Matrix.csv"),row.names=1)
> face_down_group<-read.csv(text = getURL("https://raw.githubusercontent.com/tylerascott/elwha/master/data_files/Group.Face.Down.Matrix.csv"),row.names=1)
> 
> sppsp<-read.csv(text = getURL("https://raw.githubusercontent.com/tylerascott/elwha/master/data_files/SharedParticipationMatrixPSP.csv"),row.names=1)
> spn<-read.csv(text = getURL("https://raw.githubusercontent.com/tylerascott/elwha/master/data_files/SharedParticipationMatrixN.csv"),row.names=1)
> dppsp<-read.csv(text = getURL("https://raw.githubusercontent.com/tylerascott/elwha/master/data_files/DirectParticipationMatrixPSP.csv"),row.names=1)
> dpn<-read.csv(text = getURL("https://raw.githubusercontent.com/tylerascott/elwha/master/data_files/DirectParticipationMatrixN.csv"),row.names=1)
> ip<-read.csv(text = getURL("https://raw.githubusercontent.com/tylerascott/elwha/master/data_files/IndirectParticipation.csv"),row.names=1)
> 
> 
> tname<-data.frame(network.vertex.names(net))
> colnames(tname)<-"Name"
> ww<-merge(tname,ip,by.x="Name",by.y="ORG",all.x=T)
> ww$TotPartpsp<-ifelse(is.na(ww$TotPartpsp),0,ww$TotPartpsp)
> ww$TotPartn<-ifelse(is.na(ww$TotPartn),0,ww$TotPartn)
> 
> set.vertex.attribute(net,"IPn",ww$TotPartn)
> set.vertex.attribute(net,"IPpsp",ww$TotPartpsp)
> set.vertex.attribute(net,"IPx",ww$TotPartn*ww$TotPartpsp)
> 
> set.vertex.attribute(x=net, attrname='allpart',
+                      value=get.vertex.attribute(net,'IPn')+get.vertex.attribute(net,'IPpsp'))
> set.vertex.attribute(net,'allpartdiv7',get.vertex.attribute(net,'allpart')/7) 
> set.vertex.attribute(net,'allpartdiv7quad',get.vertex.attribute(net,'allpartdiv7')^2) 
> set.vertex.attribute(net,'IPn7',get.vertex.attribute(net,'IPn')/7) 
> set.vertex.attribute(net,'IPpsp7',get.vertex.attribute(net,'IPpsp')/7) 
> set.vertex.attribute(net,'IPx7',get.vertex.attribute(net,'IPn7')*get.vertex.attribute(net,'IPpsp7')) 
> 
> 
> # 
> # 
> # set.vertex.attribute(x=net, attrname='allpartquad', value = get.vertex.attribute(net,'allpart')^2)
> # set.vertex.attribute(net,'allpartmc',get.vertex.attribute(net,'allpart') - 
> #                        mean(get.vertex.attribute(net,'allpart')))
> 
> 
> colnames(spn)<-rownames(spn)
> colnames(sppsp)<-rownames(sppsp)
> colnames(dpn)<-rownames(dpn)
> colnames(dppsp)<-rownames(dppsp)
> 
> emp<-matrix(0,nrow=(network.size(net)),ncol=network.size(net))
> colnames(emp)<-network.vertex.names(net)
> rownames(emp)<-network.vertex.names(net)
> 
> fullmatrix<-function(netx,fm)
+ {
+   emp<-matrix(0,nrow=(network.size(netx)),ncol=network.size(netx))
+   colnames(emp)<-network.vertex.names(netx)
+   rownames(emp)<-network.vertex.names(netx)
+   for (i in 1:nrow(fm))
+   {
+     for (j in 1:ncol(fm))
+     {
+       r<-which(rownames(emp)==colnames(fm)[i])
+       c<-which(colnames(emp)==colnames(fm)[j])
+       emp[r,c]<-fm[i,j]
+     }}
+   new<-emp
+   return(new)
+ }
> 
> dpn<-fullmatrix(net,dpn)
> dppsp<-fullmatrix(net,dppsp)
> sppsp<-fullmatrix(net,sppsp)
> spn<-fullmatrix(net,spn)
> 
> 
> #rm(list=ls())
> #rm(list=ls())
> install.packages('Rglpk')
Installing package into ‘/homes/tscott1/R/x86_64-pc-linux-gnu-library/3.2’
(as ‘lib’ is unspecified)
trying URL 'http://cran.fhcrc.org/src/contrib/Rglpk_0.6-0.tar.gz'
Content type 'application/x-gzip' length 18284 bytes (17 KB)
==================================================
downloaded 17 KB

* installing *source* package ‘Rglpk’ ...
** package ‘Rglpk’ successfully unpacked and MD5 sums checked
** libs
gcc -std=gnu99 -I/usr/share/R/include -DNDEBUG      -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -D_FORTIFY_SOURCE=2 -g  -c Rglpk_initialize.c -o Rglpk_initialize.o
gcc -std=gnu99 -I/usr/share/R/include -DNDEBUG      -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -D_FORTIFY_SOURCE=2 -g  -c Rglpk_read_file.c -o Rglpk_read_file.o
gcc -std=gnu99 -I/usr/share/R/include -DNDEBUG      -fpic  -g -O2 -fstack-protector-strong -Wformat -Werror=format-security -D_FORTIFY_SOURCE=2 -g  -c Rglpk_solve.c -o Rglpk_solve.o
gcc -std=gnu99 -shared -L/usr/lib/R/lib -Wl,-z,relro -o Rglpk.so Rglpk_initialize.o Rglpk_read_file.o Rglpk_solve.o -lglpk -L/usr/lib/R/lib -lR
installing to /homes/tscott1/R/x86_64-pc-linux-gnu-library/3.2/Rglpk/libs
** R
** inst
** preparing package for lazy loading
** help
*** installing help indices
** building package indices
** testing if installed package can be loaded
* DONE (Rglpk)

The downloaded source packages are in
	‘/tmp/RtmpuXGugT/downloaded_packages’
> require(statnet)
> library(snow)
> library(rlecuyer)
> library(plyr)
> library(dplyr)
> library(reshape2)
> 
> #setwd('/homes/tscott1/win/user/elwha/PSJ_Submission/Version3/min_versions')
> #load('NetworkReady.RData')
> #load('Ready_to_ERGM.RData')
> g <- sum(net %e% "TVAL")/network.dyadcount(net)
> init.geo<-log(1 - 1/(g+1))
> geo.init = init.geo
> 
> as.mcmc.default <- coda:::as.mcmc.default
> as.mcmc.list.default <- coda:::as.mcmc.list.default
> 
> dpx <- dppsp * dpn
> spx <- sppsp * spn
> spn7 <- spn/7
> spx7 <- spx/7
> sppsp7 <- sppsp/7
> dpn7 <- dpn/7
> dpx7 <- dpx/7
> dppsp7 <- dppsp/7
> ipn_pt<-get.vertex.attribute(net,'IPn7')*as.sociomatrix(net,"PRIOR_TIE")
> ippsp_pt<-get.vertex.attribute(net,'IPpsp7')*as.sociomatrix(net,"PRIOR_TIE")
> ipx_pt<-get.vertex.attribute(net,'IPx7')*as.sociomatrix(net,"PRIOR_TIE")
> dpn_pt<-dpn7*as.sociomatrix(net,"PRIOR_TIE")
> dppsp_pt<-dppsp7*as.sociomatrix(net,"PRIOR_TIE")
> dpx_pt<-dpx7*as.sociomatrix(net,"PRIOR_TIE")
> spn_pt<-spn7*as.sociomatrix(net,"PRIOR_TIE")
> sppsp_pt<-sppsp7*as.sociomatrix(net,"PRIOR_TIE")
> spx_pt<-spx7*as.sociomatrix(net,"PRIOR_TIE")
> all_sp_quad<-((spn7+sppsp7)^2)
> all_sp_pt<-((spn7+sppsp7)*as.sociomatrix(net,"PRIOR_TIE"))
> all_sp<-(spn7+sppsp7)
> central.actors = c('Federal_Agency','State_Agency','Regional_Commission')
> set.vertex.attribute(net,attrname = 'Central',
+                      value = ifelse(get.vertex.attribute(net,'ORGTYPE') %in% central.actors,1,0))
> 
> 
> form_base = net~sum+
+  # nonzero+
+   mutual(form="min")+
+   transitiveweights(twopath="min",combine="max",affect="min")+
+   nodecov("NUMRESP")+
+   nodecov("NUMGROUPS")+
+   nodecov("MEANYEARS")+
+   nodematch("ORGTYPE",diff=FALSE)#+
>  # nodefactor('Central')
>   
> npar = length(summary(form_base,response='TVAL'))-1
> 
> 
>   
> mod_base <-
+   ergm(form_base,
+        response="TVAL", reference=~DiscUnif(0,3),
+        control=control.ergm(init=c(geo.init, rep(0, npar)),
+                             MCMLE.maxit=30,MCMC.runtime.traceplot=F,seed=24,
+                             MCMLE.trustregion=1000,MCMC.addto.se=T,
+                             parallel.type="SOCK",parallel=8,
+                             MPLE.max.dyad.types=1e+7,MCMC.samplesize=50000,
+                             MCMC.burnin=15000,MCMC.interval=1500,MCMLE.steplength=.25,
+                             MCMC.prop.args=list(p0=0.5)),eval.loglik=F,verbose=T)
Evaluating network in model
Initializing Metropolis-Hastings proposal(s): ergm:MH_DiscUnif
Initializing model.
Fitting initial model.
Fitting ERGM.
Density guard set to 20989 from an initial count of 1045  edges.
Iteration 1 of at most 30 with parameter: 
                          sum                    mutual.min 
                    -3.091141                      0.000000 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                     0.000000                      0.000000 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                     0.000000                      0.000000 
        nodematch.sum.ORGTYPE 
                     0.000000 
Using SOCK.
Sample size = 50000 by 6250 
Back from unconstrained MCMC. Average statistics:
                          sum                    mutual.min 
                     -6.98910                    -267.53842 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                   -619.25658                   -7571.31108 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    -73.36882                   -6317.26620 
        nodematch.sum.ORGTYPE 
                    -27.97302 
Average estimating equation values:
                          sum                    mutual.min 
                     -6.98910                    -267.53842 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                   -619.25658                   -7571.31108 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    -73.36882                   -6317.26620 
        nodematch.sum.ORGTYPE 
                    -27.97302 
Calling MCMLE Optimization...
Using Newton-Raphson Step with step length  0.25  ...
Using lognormal metric (see control.ergm function).
Optimizing loglikelihood
Starting MCMC s.e. computation.
The log-likelihood improved by 23.34 
Step length converged once. Increasing MCMC sample size.
Iteration 2 of at most 30 with parameter: 
                          sum                    mutual.min 
                -3.1721432846                  0.4259129785 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                 0.1095306265                  0.0010278120 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                 0.0004804801                 -0.0004312951 
        nodematch.sum.ORGTYPE 
                 0.0156864026 
Using SOCK.
Sample size = 200000 by 25000 
Back from unconstrained MCMC. Average statistics:
                          sum                    mutual.min 
                    113.50144                    -236.94212 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                   -437.27422                   -7181.67670 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    998.47237                   -4384.58298 
        nodematch.sum.ORGTYPE 
                    -14.83112 
Average estimating equation values:
                          sum                    mutual.min 
                    113.50144                    -236.94212 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                   -437.27422                   -7181.67670 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    998.47237                   -4384.58298 
        nodematch.sum.ORGTYPE 
                    -14.83112 
Calling MCMLE Optimization...
Using Newton-Raphson Step with step length  0.0532606840133667  ...
Using lognormal metric (see control.ergm function).
Optimizing loglikelihood
Starting MCMC s.e. computation.
The log-likelihood improved by 6.967 
Iteration 3 of at most 30 with parameter: 
                          sum                    mutual.min 
                -3.3217212879                  0.6055886230 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                 0.1478433119                  0.0261857062 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                -0.0004118778                  0.0004092727 
        nodematch.sum.ORGTYPE 
                 0.0191232208 
Using SOCK.
Sample size = 50000 by 6250 
Back from unconstrained MCMC. Average statistics:
                          sum                    mutual.min 
                     111.3657                     -222.8397 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -404.8698                    -6718.9463 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                     965.2652                    -3940.0159 
        nodematch.sum.ORGTYPE 
                     -15.8913 
Average estimating equation values:
                          sum                    mutual.min 
                     111.3657                     -222.8397 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -404.8698                    -6718.9463 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                     965.2652                    -3940.0159 
        nodematch.sum.ORGTYPE 
                     -15.8913 
Calling MCMLE Optimization...
Using Newton-Raphson Step with step length  0.066983848810196  ...
Using lognormal metric (see control.ergm function).
Optimizing loglikelihood
Starting MCMC s.e. computation.
The log-likelihood improved by 7.584 
Iteration 4 of at most 30 with parameter: 
                          sum                    mutual.min 
                -3.4837906949                  0.7702075742 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                 0.1810311719                  0.0487847354 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                -0.0005691991                  0.0018479346 
        nodematch.sum.ORGTYPE 
                 0.0568926546 
Using SOCK.
Sample size = 50000 by 6250 
Back from unconstrained MCMC. Average statistics:
                          sum                    mutual.min 
                    121.06422                    -204.19538 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                   -352.68736                   -6089.56482 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                   1087.29004                   -3129.88957 
        nodematch.sum.ORGTYPE 
                     -9.31358 
Average estimating equation values:
                          sum                    mutual.min 
                    121.06422                    -204.19538 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                   -352.68736                   -6089.56482 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                   1087.29004                   -3129.88957 
        nodematch.sum.ORGTYPE 
                     -9.31358 
Calling MCMLE Optimization...
Using Newton-Raphson Step with step length  0.0667028427124025  ...
Using lognormal metric (see control.ergm function).
Optimizing loglikelihood
Starting MCMC s.e. computation.
The log-likelihood improved by 4.299 
Iteration 5 of at most 30 with parameter: 
                          sum                    mutual.min 
                 -3.562864116                   0.896039852 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                  0.195160380                   0.062937831 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                 -0.002012802                   0.002072245 
        nodematch.sum.ORGTYPE 
                  0.077886569 
Using SOCK.
Sample size = 50000 by 6250 
Back from unconstrained MCMC. Average statistics:
                          sum                    mutual.min 
                     117.0084                     -188.6935 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -318.3560                    -5652.0752 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    1039.3561                    -2897.2762 
        nodematch.sum.ORGTYPE 
                      -6.8515 
Average estimating equation values:
                          sum                    mutual.min 
                     117.0084                     -188.6935 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -318.3560                    -5652.0752 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    1039.3561                    -2897.2762 
        nodematch.sum.ORGTYPE 
                      -6.8515 
Calling MCMLE Optimization...
Using Newton-Raphson Step with step length  0.0939102172851564  ...
Using lognormal metric (see control.ergm function).
Optimizing loglikelihood
Starting MCMC s.e. computation.
The log-likelihood improved by 5.937 
Iteration 6 of at most 30 with parameter: 
                          sum                    mutual.min 
                 -3.651641264                   1.051127756 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                  0.198562924                   0.077280571 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                 -0.003849965                   0.002982206 
        nodematch.sum.ORGTYPE 
                  0.090065875 
Using SOCK.
Sample size = 50000 by 6250 
Back from unconstrained MCMC. Average statistics:
                          sum                    mutual.min 
                    108.95916                    -167.63186 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                   -287.24284                   -5070.47134 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    910.03083                   -2563.90188 
        nodematch.sum.ORGTYPE 
                     -6.87926 
Average estimating equation values:
                          sum                    mutual.min 
                    108.95916                    -167.63186 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                   -287.24284                   -5070.47134 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    910.03083                   -2563.90188 
        nodematch.sum.ORGTYPE 
                     -6.87926 
Calling MCMLE Optimization...
Using Newton-Raphson Step with step length  0.0988261699676515  ...
Using lognormal metric (see control.ergm function).
Optimizing loglikelihood
Starting MCMC s.e. computation.
The log-likelihood improved by 4.266 
Iteration 7 of at most 30 with parameter: 
                          sum                    mutual.min 
                 -3.708601080                   1.137975146 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                  0.202862286                   0.089612716 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                 -0.005805413                   0.003003338 
        nodematch.sum.ORGTYPE 
                  0.086751584 
Using SOCK.
Sample size = 50000 by 6250 
Back from unconstrained MCMC. Average statistics:
                          sum                    mutual.min 
                     98.29306                    -151.50900 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                   -254.17994                   -4520.95786 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    764.70572                   -2356.85152 
        nodematch.sum.ORGTYPE 
                    -10.61688 
Average estimating equation values:
                          sum                    mutual.min 
                     98.29306                    -151.50900 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                   -254.17994                   -4520.95786 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    764.70572                   -2356.85152 
        nodematch.sum.ORGTYPE 
                    -10.61688 
Calling MCMLE Optimization...
Using Newton-Raphson Step with step length  0.133218765258789  ...
Using lognormal metric (see control.ergm function).
Optimizing loglikelihood
Starting MCMC s.e. computation.
The log-likelihood improved by 4.903 
Iteration 8 of at most 30 with parameter: 
                          sum                    mutual.min 
                 -3.767572473                   1.251691427 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                  0.197179641                   0.100394854 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                 -0.007729270                   0.003676686 
        nodematch.sum.ORGTYPE 
                  0.107892889 
Using SOCK.
Sample size = 50000 by 6250 
Back from unconstrained MCMC. Average statistics:
                          sum                    mutual.min 
                    107.47574                    -126.46466 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                   -195.56348                   -3788.84550 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    810.78461                   -1660.50022 
        nodematch.sum.ORGTYPE 
                     -8.12782 
Average estimating equation values:
                          sum                    mutual.min 
                    107.47574                    -126.46466 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                   -195.56348                   -3788.84550 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    810.78461                   -1660.50022 
        nodematch.sum.ORGTYPE 
                     -8.12782 
Calling MCMLE Optimization...
Using Newton-Raphson Step with step length  0.167504668235779  ...
Using lognormal metric (see control.ergm function).
Optimizing loglikelihood
Starting MCMC s.e. computation.
The log-likelihood improved by 4.947 
Iteration 9 of at most 30 with parameter: 
                          sum                    mutual.min 
                 -3.833779228                   1.339414379 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                  0.184500372                   0.111157688 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                 -0.008843893                   0.004584485 
        nodematch.sum.ORGTYPE 
                  0.126560901 
Using SOCK.
Sample size = 50000 by 6250 
Back from unconstrained MCMC. Average statistics:
                          sum                    mutual.min 
                     107.5956                     -104.0199 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -142.1943                    -3045.7167 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                     797.8540                     -854.6550 
        nodematch.sum.ORGTYPE 
                      -6.9442 
Average estimating equation values:
                          sum                    mutual.min 
                     107.5956                     -104.0199 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -142.1943                    -3045.7167 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                     797.8540                     -854.6550 
        nodematch.sum.ORGTYPE 
                      -6.9442 
Calling MCMLE Optimization...
Using Newton-Raphson Step with step length  0.203510284423829  ...
Using lognormal metric (see control.ergm function).
Optimizing loglikelihood
Starting MCMC s.e. computation.
The log-likelihood improved by 4.556 
Iteration 10 of at most 30 with parameter: 
                          sum                    mutual.min 
                 -3.909145404                   1.432102443 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                  0.170233742                   0.120439473 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                 -0.008761950                   0.005284731 
        nodematch.sum.ORGTYPE 
                  0.162170302 
Using SOCK.
Sample size = 50000 by 6250 
Back from unconstrained MCMC. Average statistics:
                          sum                    mutual.min 
                      89.9444                      -81.3846 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -108.6030                    -2400.2836 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                     709.4319                     -654.9489 
        nodematch.sum.ORGTYPE 
                      -3.7087 
Average estimating equation values:
                          sum                    mutual.min 
                      89.9444                      -81.3846 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -108.6030                    -2400.2836 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                     709.4319                     -654.9489 
        nodematch.sum.ORGTYPE 
                      -3.7087 
Calling MCMLE Optimization...
Using Newton-Raphson Step with step length  0.243360757827759  ...
Using lognormal metric (see control.ergm function).
Optimizing loglikelihood
Starting MCMC s.e. computation.
The log-likelihood improved by 3.554 
Iteration 11 of at most 30 with parameter: 
                          sum                    mutual.min 
                 -3.973792670                   1.504966944 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                  0.156907705                   0.128161453 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                 -0.008627877                   0.005907825 
        nodematch.sum.ORGTYPE 
                  0.178264378 
Using SOCK.
Sample size = 50000 by 6250 
Back from unconstrained MCMC. Average statistics:
                          sum                    mutual.min 
                     81.29304                     -61.52080 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -73.78724                   -1845.21848 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    664.64797                    -255.37373 
        nodematch.sum.ORGTYPE 
                     -1.50204 
Average estimating equation values:
                          sum                    mutual.min 
                     81.29304                     -61.52080 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -73.78724                   -1845.21848 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    664.64797                    -255.37373 
        nodematch.sum.ORGTYPE 
                     -1.50204 
Calling MCMLE Optimization...
Using Newton-Raphson Step with step length  0.25  ...
Using lognormal metric (see control.ergm function).
Optimizing loglikelihood
Starting MCMC s.e. computation.
The log-likelihood improved by 2.657 
Step length converged once. Increasing MCMC sample size.
Iteration 12 of at most 30 with parameter: 
                          sum                    mutual.min 
                 -4.024256203                   1.554790942 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                  0.138294979                   0.136310215 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                 -0.009100713                   0.006256520 
        nodematch.sum.ORGTYPE 
                  0.190747427 
Using SOCK.
Sample size = 200000 by 25000 
Back from unconstrained MCMC. Average statistics:
                          sum                    mutual.min 
                     55.94328                     -46.97355 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -59.96388                   -1359.26374 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    470.69155                    -279.92983 
        nodematch.sum.ORGTYPE 
                     -3.41227 
Average estimating equation values:
                          sum                    mutual.min 
                     55.94328                     -46.97355 
transitiveweights.min.max.min          nodecov.sum..NUMRESP 
                    -59.96388                   -1359.26374 
       nodecov.sum..NUMGROUPS        nodecov.sum..MEANYEARS 
                    470.69155                    -279.92983 
        nodematch.sum.ORGTYPE 
                     -3.41227 
Calling MCMLE Optimization...
Using Newton-Raphson Step with step length  0.25  ...
Using lognormal metric (see control.ergm function).
Optimizing loglikelihood
Starting MCMC s.e. computation.
The log-likelihood improved by 1.361 
Step length converged twice. Stopping.

This model was fit using MCMC.  To examine model diagnostics and check for degeneracy, use the mcmc.diagnostics() function.
Warning message:
In logLikNull.ergm(mainfit) :
  Null model likelihood calculation is not implemented for valued ERGMs at this time.
> 
> sim_base = simulate.ergm(mod_base,nsim = 200000,statsonly=TRUE,response="TVAL", reference=~DiscUnif(0,3),
+                     control=control.simulate.ergm(MCMC.burnin=15000,
+                                                   MCMC.interval=1500,
+                                                   MCMC.prop.args=list(p0=0.5),
+                                                   MCMC.runtime.traceplot=FALSE,
+                                                   parallel=8,
+                                                   parallel.type='SOCK'))
> 
> sim_base.dat = melt(sim_base,id.vars=rownames(sim_base))
> 
> save.image('result_base_nll.RData')
> 
> # mod_indpart3<-
> #   ergm(net~sum+mutual(form="min")+
> #          transitiveweights("min","max","min")+nodecov("NUMRESP")+
> #          nodecov("NUMGROUPS")+nodecov("MEANYEARS")+nodematch("ORGTYPE",form='sum')+
> #          nodecov('IPn7')+nodecov('IPpsp7')+nodecov('IPx7'),
> #        response="TVAL", reference=~DiscUnif(0,3),
> #        control=control.ergm(init=c(geo.init, rep(0, 9)),
> #                             MCMLE.maxit=30,MCMC.runtime.traceplot=F,seed=24,
> #                             MCMLE.trustregion=1000,MCMC.addto.se=T,parallel.type="SOCK",
> #                             MPLE.max.dyad.types=1e+7,parallel=4,MCMC.samplesize=16000,
> #                             MCMC.burnin=10000,MCMC.interval=1000,MCMLE.steplength=.25,
> #                             MCMC.prop.args=list(p0=0.5)),eval.loglik=T)
> # 
> # mod_indpart<-mod_indpart3
> # 
> # mod_dirpart <-
> #     ergm(net~sum+mutual(form="min")+
> # transitiveweights("min","max","min")+nodecov("NUMRESP")+
> # nodecov("NUMGROUPS")+nodecov("MEANYEARS")+nodematch("ORGTYPE")+
> # edgecov(dpn7,form='sum')+edgecov(dppsp7,form='sum')+edgecov(dpx7,form='sum'),
> #          response="TVAL", reference=~DiscUnif(0,3),
> #          control=control.ergm(init=c(geo.init, rep(0, 9)),
> #                               MCMLE.maxit=30,MCMC.runtime.traceplot=F,seed=24,
> #                               MCMLE.trustregion=1000,MCMC.addto.se=T,
> #                               parallel.type="MPI",parallel=8,
> #                               MPLE.max.dyad.types=1e+7,MCMC.samplesize=50000,
> #                               MCMC.burnin=15000,MCMC.interval=1500,MCMLE.steplength=.25,
> #                               MCMC.prop.args=list(p0=0.5)),eval.loglik=T)
> # 
> # mod_shapart <-
> #   ergm(net~sum+mutual(form="min")+
> #          transitiveweights("min","max","min")+nodecov("NUMRESP")+
> #          nodecov("NUMGROUPS")+nodecov("MEANYEARS")+nodematch("ORGTYPE",form='sum')+
> #          edgecov(spn7,form='sum')+edgecov(sppsp7,form='sum')+edgecov(spx7,form='sum'),
> #        response="TVAL", reference=~DiscUnif(0,3),
> #        control=control.ergm(init=c(geo.init, rep(0, 9)),
> #                             MCMLE.maxit=30,MCMC.runtime.traceplot=F,seed=24,
> #                             MCMLE.trustregion=1000,MCMC.addto.se=T,
> #                             parallel.type="MPI",parallel=8,
> #                             MPLE.max.dyad.types=1e+7,MCMC.samplesize=50000,
> #                             MCMC.burnin=15000,MCMC.interval=1500,MCMLE.steplength=.25,
> #                             MCMC.prop.args=list(p0=0.5)),eval.loglik=T)
> # 
> # detach(file:NetworkReady.RData)
> # 
> # rm(
> # list=ls()[intersect(grep('shapart',ls(),invert=T),grep('dirpart',ls(),
> #                                                        invert=T))])
> 
> rm(list=ls())
> 
