worst.overall = arrange(stack(tapply(qc$Coverage.Index,qc$Country,mean)),values)
best.overall = worst.overall %>% filter(!is.na(values)) %>% arrange(-values)
keep = c(as.character(best.overall$ind[1:10]),as.character(worst.overall$ind[1:10]))
qc2 = qc %>% filter(as.character(qc$Country) %in% keep)
qc2$which = ifelse(qc2$Country %in% keep[1:10],'High','Low')
qc2$Overall = best.overall$values[match(qc2$Country,best.overall$ind)]
qc2$qnum = as.numeric(qc2$qnum)
ggplot(qc2,aes(x=as.numeric(qnum),y=Coverage.Index))+
geom_line(aes(group=Country,colour=as.numeric(Overall)))+
scale_x_discrete(expand=c(0,0))+
xlab('Quantile')+
scale_color_continuous(low='red',high='dark blue','Overall Coverage',limits=c(0,100))+
theme_bw()
library(scales)
qc$the.pc = eff$the.pc[match(qc$Country,eff$Country)]
qc$hwd = eff$hwd[match(qc$Country,eff$Country)]
qc$quintile.in.quintile = 0
qc$quintile.in.quintile[qc$qnum==1] = cut_interval(qc$Coverage.Index[qc$qnum==1],n=5,labels=1:5)
qc$quintile.in.quintile[qc$qnum==2] = cut_interval(qc$Coverage.Index[qc$qnum==2],n=5,labels=1:5)
qc$quintile.in.quintile[qc$qnum==3] = cut_interval(qc$Coverage.Index[qc$qnum==3],n=5,labels=1:5)
qc$quintile.in.quintile[qc$qnum==4] = cut_interval(qc$Coverage.Index[qc$qnum==4],n=5,labels=1:5)
qc$quintile.in.quintile[qc$qnum==5] = cut_interval(qc$Coverage.Index[qc$qnum==5],n=5,labels=1:5)
temp1 = stack(tapply(qc$Coverage.Index, paste(qc$qnum,qc$quintile.in.quintile,sep='.'),mean))
temp2 = stack(tapply(scale(qc$hwd), paste(qc$qnum,qc$quintile.in.quintile,sep='.'),mean,na.rm=TRUE))
temp3 = stack(tapply(scale(qc$the.pc), paste(qc$qnum,qc$quintile.in.quintile,sep='.'),mean,na.rm=TRUE))
temp1$qnum = rep(1:5,each=5)
temp2$qnum = rep(1:5,each=5)
temp3$qnum = rep(1:5,each=5)
temp1$inqnum = rep(1:5,5)
temp2$inqnum = rep(1:5,5)
temp3$inqnum = rep(1:5,5)
colnames(temp1) = c('ci.avg','qq','qnum','inqnum')
colnames(temp2) = c('hwd.avg','qq','qnum','inqnum')
colnames(temp3) = c('the.avg','qq','qnum','inqnum')
qq.avg = join_all(list(temp1,temp2,temp3))
temp = qq.avg
temp = melt(temp,id.vars=c('qq','qnum','inqnum'))
temp = temp[temp$variable!='ci.avg',]
levels(temp$variable) = c('Mean Coverage Index','Health Worker Density','Tot. Health Exp. (per capita)')
ggplot(data=temp) +
geom_tile(aes(x=qnum,y=inqnum,fill=value))+facet_wrap(~variable)+
scale_fill_gradient2('Std. Value',low = muted("red"), mid = "grey",
high = muted("blue"), midpoint = mean(qq.avg$hwd.avg),limits=c(-1,1)) + theme_bw()+
xlab('Income Quintile (w/in Country)')+
ylab('Coverage Q-rank w/in Income Quintile')
length(unique(qc$Country))
n = length(unique(qc$Country))
n
ggplot(data=temp) +
geom_tile(aes(x=qnum,y=inqnum,fill=value))+facet_wrap(~variable)+
scale_fill_gradient2('Std. Value',low = muted("red"), mid = "grey",
high = muted("blue"), midpoint = mean(qq.avg$hwd.avg),limits=c(-1,1)) + theme_bw()+
xlab(paste('Income Quintile (w/in Country) ( N =', n,sep=' ')+
ylab('Coverage Q-rank w/in Income Quintile')
ggplot(data=temp) +
geom_tile(aes(x=qnum,y=inqnum,fill=value))+facet_wrap(~variable)+
scale_fill_gradient2('Std. Value',low = muted("red"), mid = "grey",
high = muted("blue"), midpoint = mean(qq.avg$hwd.avg),limits=c(-1,1)) + theme_bw()+
xlab(paste('Income Quintile (w/in Country) ( N =', n,sep=' '))+
ylab('Coverage Q-rank w/in Income Quintile')
ggplot(data=temp) +
geom_tile(aes(x=qnum,y=inqnum,fill=value))+facet_wrap(~variable)+
scale_fill_gradient2('Std. Value',low = muted("red"), mid = "grey",
high = muted("blue"), midpoint = mean(qq.avg$hwd.avg),limits=c(-1,1)) + theme_bw()+
xlab(paste(paste('Income Quintile (w/in Country) (N =', n,sep=' ')),')',sep='')+
ylab('Coverage Q-rank w/in Income Quintile')
ggplot(data=temp) +
geom_tile(aes(x=qnum,y=inqnum,fill=value))+facet_wrap(~variable)+
scale_fill_gradient2('Std. Value',low = muted("red"), mid = "grey",
high = muted("blue"), midpoint = mean(qq.avg$hwd.avg),limits=c(-1,1)) + theme_bw()+
xlab(paste(paste('Income Quintile (w/in Country) (N =', n,sep=' '),')',sep='')+
ylab('Coverage Q-rank w/in Income Quintile')
ggplot(data=temp) +
geom_tile(aes(x=qnum,y=inqnum,fill=value))+facet_wrap(~variable)+
scale_fill_gradient2('Std. Value',low = muted("red"), mid = "grey",
high = muted("blue"), midpoint = mean(qq.avg$hwd.avg),limits=c(-1,1)) + theme_bw()+
xlab(paste(paste('Income Quintile (w/in Country) (N =', n,sep=' '),')',sep=''))+
ylab('Coverage Q-rank w/in Income Quintile')
ggplot(data=temp) +
geom_tile(aes(x=qnum,y=inqnum,fill=value))+facet_wrap(~variable)+
scale_fill_gradient2('Std. Value',low = muted("red"), mid = "grey",
high = muted("blue"), midpoint = mean(qq.avg$hwd.avg),limits=c(-1,1)) + theme_bw()+
xlab(paste(paste('Income Quintile (w/in Country) (N =', n,sep=' '),')',sep=''))+
ylab('Coverage Q-rank w/in Income Quintile')
temp = eff
temp$CI.q = cut_interval(temp$cov.index,n=5,labels=1:5)
tt = stack(tapply(temp$cov.index,temp$CI.q,mean));colnames(tt) = c('Avg.CI.q','CI.q')
temp = join(temp,tt)
tt = stack(tapply(temp$hwd,temp$CI.q,mean,na.rm=T));colnames(tt) = c('Avg.hwd.CI.q','CI.q')
temp = join(temp,tt)
tt = stack(tapply(temp$the.pc,temp$CI.q,mean,na.rm=T));colnames(tt) = c('Avg.the.CI.q','CI.q')
temp = join(temp,tt)
temp = melt(temp,measure.vars=c('Avg.hwd.CI.q','Avg.the.CI.q'))
levels(temp$variable) = c('Mean Health Worker Density','Mean Tot. Health Exp.')
ggplot(temp,aes(x=Avg.CI.q,y=value))+
geom_point(aes(x=Avg.CI.q,y=value,label=paste('Q',CI.q,sep='')),shape=1,size=10)+
geom_text(aes(x=Avg.CI.q,y=value,label=paste('Q',CI.q,sep='')),size=4)+
facet_wrap(~variable,scales = 'free')+
scale_x_continuous(expand=c(0,0),limits=c(20,100),breaks=c(20,40,60,80,100))+
ylab('Input Metric') + xlab('Coverage Index (mean w/in quintile)') + theme_bw()
length(unique(temp$Country)
length(unique(temp$Country))
length(unique(temp$Country))
ggplot(temp,aes(x=Avg.CI.q,y=value))+
geom_point(aes(x=Avg.CI.q,y=value,label=paste('Q',CI.q,sep='')),shape=1,size=10)+
geom_text(aes(x=Avg.CI.q,y=value,label=paste('Q',CI.q,sep='')),size=4)+
facet_wrap(~variable,scales = 'free')+
scale_x_continuous(expand=c(0,0),limits=c(20,100),breaks=c(20,40,60,80,100))+
ylab('Input Metric') +
xlab(paste(paste('Coverage Index (mean w/in quintile) (N =', n,sep=' '),')',sep=''))+
theme_bw()
n = length(unique(temp$Country))
ggplot(temp,aes(x=Avg.CI.q,y=value))+
geom_point(aes(x=Avg.CI.q,y=value,label=paste('Q',CI.q,sep='')),shape=1,size=10)+
geom_text(aes(x=Avg.CI.q,y=value,label=paste('Q',CI.q,sep='')),size=4)+
facet_wrap(~variable,scales = 'free')+
scale_x_continuous(expand=c(0,0),limits=c(20,100),breaks=c(20,40,60,80,100))+
ylab('Input Metric') +
xlab(paste(paste('Coverage Index (mean w/in quintile) (N =', n,sep=' '),')',sep=''))+
theme_bw()
temp = eff %>% filter(!is.na(eff$cov.index))
print(ggplot(temp,aes(x=cov.index)) +
geom_histogram(aes(y=..density..),      # Histogram with density instead of count on y-axis
binwidth=5,
colour="black", fill="grey80") +
geom_density(alpha=.2, fill="#FF6666",binwidth=1) +
ylab('Density')+
theme(axis.ticks = element_blank(),
panel.background =  element_rect(fill = "white", colour = NA))+
scale_x_continuous(expand=c(0,0),breaks=c(20,30,40,50,60,70,80,90,100),limits=c(10,100))+
scale_y_continuous(expand=c(0,0))+
geom_text(aes(x=20,y=.005,label=paste('N =',nrow(temp),sep=' ')))+
xlab('Coverage Index'))
ggplot(eff[!is.na(eff$the),],aes(x=((the*1000000)/Population))) +
geom_histogram(aes(y=..density..),      # Histogram with density instead of count on y-axis
colour="black", fill="grey80") +
geom_density(alpha=.2, fill="#FF6666",binwidth=1) +
ylab('Density')+
theme(axis.ticks = element_blank(),
panel.background =  element_rect(fill = "white", colour = NA))+
scale_x_continuous(expand=c(0,0))+
scale_y_continuous(expand=c(0,0))+
xlab('Total Health Expenditure ($) per capita')
temp = eff %>% filter(!is.na(eff$the))
ggplot(temp,aes(x=((the*1000000)/Population))) +
geom_histogram(aes(y=..density..),      # Histogram with density instead of count on y-axis
colour="black", fill="grey80") +
geom_density(alpha=.2, fill="#FF6666",binwidth=1) +
ylab('Density')+
theme(axis.ticks = element_blank(),
panel.background =  element_rect(fill = "white", colour = NA))+
scale_x_continuous(expand=c(0,0))+
scale_y_continuous(expand=c(0,0))+
geom_text(aes(x=3000,y=.0005,label=paste('N =',nrow(temp),sep=' ')))+
xlab('Total Health Expenditure ($) per capita')
ggplot(eff[!is.na(eff$hwd),],aes(x=(hwd))) +
geom_histogram(aes(y=..density..),      # Histogram with density instead of count on y-axis
colour="black", fill="grey80") +
geom_density(alpha=.2, fill="#FF6666",binwidth=1) +
ylab('Density')+
theme(axis.ticks = element_blank(),
panel.background =  element_rect(fill = "white", colour = NA))+
scale_x_continuous(expand=c(0,0))+
scale_y_continuous(expand=c(0,0))+
xlab('Health Worker Density')
temp = eff %>% filter(!is.na(eff$hwd))
ggplot(temp,aes(x=(hwd))) +
geom_histogram(aes(y=..density..),      # Histogram with density instead of count on y-axis
colour="black", fill="grey80") +
geom_density(alpha=.2, fill="#FF6666",binwidth=1) +
ylab('Density')+
theme(axis.ticks = element_blank(),
panel.background =  element_rect(fill = "white", colour = NA))+
scale_x_continuous(expand=c(0,0))+
scale_y_continuous(expand=c(0,0))+
geom_text(aes(x=5.5,y=.25,label=paste('N =',nrow(temp),sep=' ')))+
xlab('Health Worker Density')
?round
?paste
temp = eff %>% filter(!is.na(eff1b)) %>% filter(!is.na(eff2)) %>% filter(eff1b<40)
ggplot(data=temp)+
geom_text(aes(x=eff1b+.05,y=eff2+40,label=Country.Code),
size=4,data=temp[temp$eff2>=500|temp$eff1b>1,])+
geom_point(aes(x=eff1b,y=eff2),data=temp)    +
geom_smooth(aes(x=eff1b,y=eff2), method="lm",alpha=.24) + theme_bw() +
xlab('Cov. Index / Tot. Health Exp.')+
geom_text(aes(x=4,y=110,label=paste('N =',nrow(temp),sep=' ')))+
ylab('Cov. Index / Health Worker Dens.')
cor(temp$eff1b,temp$eff2)
temp = eff %>% filter(!is.na(eff1b)) %>% filter(!is.na(eff2)) %>%
filter(eff1b<2) %>% filter(eff2<1000)
ggplot(data=temp)+
geom_point(aes(x=eff1b,y=eff2))    +
geom_smooth(aes(x=eff1b,y=eff2), method="lm",alpha=.24) + theme_bw() +
xlab('Coverage Index / Total Health Exp.')+
ylab('Coverage Index / Health Worker Dens.')+
geom_text(aes(x=1.35,y=100,label=paste('N =',nrow(temp),sep=' ')))
cor2 = cor(temp$eff1b,temp$eff2)
cor2
temp = eff %>% filter(!is.na(eff1b)) %>% filter(!is.na(eff2)) %>% filter(eff1b<40)
ggplot(data=temp)+
geom_text(aes(x=eff1b+.05,y=eff2+40,label=Country.Code),
size=4,data=temp[temp$eff2>=500|temp$eff1b>1,])+
geom_point(aes(x=eff1b,y=eff2),data=temp)    +
geom_smooth(aes(x=eff1b,y=eff2), method="lm",alpha=.24) + theme_bw() +
xlab('Cov. Index / Tot. Health Exp.')+
geom_text(aes(x=4,y=110,label=paste('N =',nrow(temp),sep=' ')))+
ylab('Cov. Index / Health Worker Dens.')
cor1 = cor(temp$eff1b,temp$eff2)
cor1
temp = read.csv('//Users/TScott/Google Drive/PSI_HWBindicators/gcs_data/Response_Rate_Summary.csv')
head(temp)
library(plyr)
library(dplyr)
temp = mutate(temp,Rate = Q6.Responses/Q1.Impressions)
temp$Rate
max(temp$Rate)
min(temp$Rate)
median(temp$Rate)
sum(temp$Q1.Impressions)
sum(temp$Q6.Responses)
sum(temp$Q6.Responses)/sum(temp$Q1.Impressions)
-1.78 * 10^3
plot.data = data.frame(x = seq(1,100,1))
budget = 100
plot.data = data.frame(x = seq(0,budget,1))
plot.data$y = seq(budget,0,1)
seq(budget,0,1)
?seq
budget:0
budget = 100
plot.data = data.frame(x = seq(0,budget,1))
plot.data$y = budget:0
head(plot.data)
plot(plot.data$x,plot.data$y)
budget = 100
plot.data = data.frame(x = seq(0,budget,1))
plot.data$y = budget:0
alpha = .5; beta = .5
plot.data$q = (plot.data$x^alpha) * (plot.data$y^beta)
head(plot.data)
prod <- c(                                         100, 101,
112, 122, 124, 122, 143, 152, 151, 126, 155, 159,
153, 177, 184, 169, 189, 225, 227, 223, 218, 231,
179, 240 )
lab  <- c(                                         100, 105,
110, 117, 122, 121, 125, 134, 140, 123, 143, 147,
148, 155, 156, 152, 156, 183, 198, 201, 196, 194,
146, 161 )
cap  <- c(                                         100, 107,
114, 122, 131, 138, 149, 163, 176, 185, 198, 208,
216, 226, 236, 244, 266, 298, 335, 366, 387, 407,
417, 431 )
cd   <- data.frame( prod = prod, lab = lab, cap = cap )
row.names( cd ) <- 1899:1922
##  The model proposed by Cobb and Douglas is:
##      prod = b * lab ^ alpha * cap ^ ( 1 - alpha ),
##  where b and alpha are the model parameters.
##
##  This model can be converted to a linear model by taking the log of both
##  sides of the equation:
##      log( prod ) = log( b ) + alpha * log( lab ) +
##          ( 1 - alpha ) * log( cap )
##
##  The formula estimates the two parameters we desire, where log( b ) is
##  estimated by the Intercept coefficient.
cd.lm <-
lm(
formula = I( log( prod ) - log( cap ) ) ~ I( log( lab ) - log( cap ) ),
data    = cd )
summary( cd.lm )
##  Coefficients:
##                         Estimate Std. Error t value Pr(>|t|)
##  (Intercept)            0.007044   0.020134    0.35     0.73
##  I(log(lab) - log(cap)) 0.744606   0.042205   17.64  1.8e-14 ***
##  Plot the fitted surface for the ranges of values from the data.
##
##  Open the default device.
get( getOption( "device" ) )()
##  Expand the plot limits to include all the sample points.
##  The x and y coordinates of the plot are stored in variables x and y.
interval <- 10
x <-
seq(
from = floor( min( cd$lab ) / interval ) * interval,
to   = ceiling( max( cd$lab ) / interval ) * interval,
by   = interval )
y <-
seq(
from = floor( min( cd$cap ) / interval ) * interval,
to   = ceiling( max( cd$cap ) / interval ) * interval,
by   = interval )
##  Calculate the z coordinates of the plot.
##  f() is the function that predicts the z value from the x and y,
##  that is, prod from lab and cap.
f <-
function( x, y )
{
exp( coef( cd.lm )[ 1 ] ) * ( x ^ coef( cd.lm )[ 2 ] ) *
( y ^ ( 1 - coef( cd.lm )[ 2 ] ) )
}
z <- outer( x, y, f )
##  Calculate the plotting limits for the z coordinate.
zlim <- c( floor( min( z ) ), ceiling( max( z ) ) )
##  Calculate the fitted values and add them to the data.frame.
##  The fitted values can also be obtained from cd5.lm using the
##  function fitted().
cd$prod.hat <- f( x = cd$lab, y = cd$cap )
##  Create a perspective plot.
##  theta is the angle of perspective for rotation around the z axis.
##  phi is the angle of perspective above the x-y plane.
theta <- -60
phi <- 10
cd.persp <-
persp(
x        = x,
y        = y,
z        = z,
theta    = theta,
phi      = phi,
col      = "lightblue",
ltheta   = -135,
shade    = 0.5,
ticktype = "detailed",
main     = "Cobb-Douglas  Production Function 1899-1922",
xlab     = "Labor",
ylab     = "Capital",
zlab     = "Production",
zlim     = zlim,
scale    = FALSE,
border   = NA,
nticks   = 4 )
##  Plot the data points, using the color "gray32" for points below the
##  surface and the color "black" for points above the surface.
##
##  Convert the 3-D coordinates of the points to the 2-D drawing coordinates
##  using trans3d().
##
##  Draw a line from the observed point to the corresponding fitted value
##  on the surface as an aid to visualizing the position of the point
##  in 3-D space.
##
##  First, plot the data points that are below the surface.
##  pch = 16 designates a filled circle symbol.
cd.below <- subset( cd, cd$prod < cd$prod.hat )
cd.below.trans3d <-
trans3d(
x    = cd.below$lab,
y    = cd.below$cap,
z    = cd.below$prod,
pmat = cd.persp )
points( cd.below.trans3d, col = "gray32", pch = 16 )
##  Convert the coordinates of the fitted values.
cd.below.hat.trans3d <-
trans3d(
x    = cd.below$lab,
y    = cd.below$cap,
z    = cd.below$prod.hat,
pmat = cd.persp )
##  Draw lines from the observed points to the fitted points.
segments(
x0  = cd.below.trans3d$x,
y0  = cd.below.trans3d$y,
x1  = cd.below.hat.trans3d$x,
y1  = cd.below.hat.trans3d$y,
lty = "solid",
col = "gray32" )
##  Second, plot the data points that are above the surface.
cd.above <- subset( cd, cd$prod >= cd$prod.hat )
cd.above.trans3d <-
trans3d(
x    = cd.above$lab,
y    = cd.above$cap,
z    = cd.above$prod,
pmat = cd.persp )
points( cd.above.trans3d, col = "black", pch = 16 )
cd.above.hat.trans3d <-
trans3d(
x    = cd.above$lab,
y    = cd.above$cap,
z    = cd.above$prod.hat,
pmat = cd.persp )
segments(
x0  = cd.above.trans3d$x,
y0  = cd.above.trans3d$y,
x1  = cd.above.hat.trans3d$x,
y1  = cd.above.hat.trans3d$y,
lty = "solid",
col = "black" )
summary( cd.lm )
head(cd)
plot()
abline(h=2)
abline(h=2)
plot.new()
abline(h=2)
abline(v=2)
ggplot()+scale_x_continuous('costs')
library(ggplot2)
ggplot()+scale_x_continuous('costs')
plot.data = data.frame(x=c(1:10),y=c(1:10))
ggplot(plot.data)+scale_x_continuous('costs')
ggplot(plot.data,aes(x=x,y=y))+scale_x_continuous('costs')
ggplot(plot.data,aes(x=x,y=y))+geom_line()+scale_x_continuous('costs')
0.04 + (2)(-5.81 x 10-6)(3104.9462) = 0.036
0.04 + (2)(-5.81 x 10^-6)(3104.9462)
0.04 + (2)(-5.81 x 10^-6)(3104.9462)
0.04 + (2)(-5.81 x 10^-6)*(3104.9462)
0.04 + (2)*(-5.81 x 10^-6)*(3104.9462)
0.04 + (2*(-5.81 x 10^-6)*(3104.9462))
0.04 + (2*(-5.81 * 10^-6)*(3104.9462))
0.04 + (2*(-5.81 * 10^-6)*(2072.6818))
0.04 + (2*(-5.81 * 10^-6)*(2588.814))
0.04 + (2*(-5.81 * 10^-6)*(3104.9462))
install.packages('xergm',repos='https://r-forge.r-project.org/projects/xergm/',
type='source')
library(statnet)
y <- network.initialize(2,directed=FALSE) # A network with one dyad!
sim.du3<-simulate(y~sum, coef=0, reference=~DiscUnif(0,3),
response="w",statsonly=TRUE,nsim=1000)
plot(sim.du3)
hist(sim.du3,breaks=diff(range(sim.du3))*4)
y <- network.initialize(20,directed=FALSE) # A network with one dyad!
sim.du3<-simulate(y~sum, coef=0, reference=~DiscUnif(0,3),
response="w",statsonly=TRUE,nsim=1000)
hist(sim.du3,breaks=diff(range(sim.du3))*4)
y <- network.initialize(400,directed=FALSE) # A network with one dyad!
sim.du3<-simulate(y~sum, coef=0, reference=~DiscUnif(0,3),
response="w",statsonly=TRUE,nsim=1000)
hist(sim.du3,breaks=diff(range(sim.du3))*4)
sqrt(2*8)
sqrt(2)*sqrt(8)
sqrt(2*10)
sqrt(2)*sqrt(10)
sqrt(2)*sqrt(1)
sqrt(2)*sqrt(2)
sqrt(2)*sqrt(3)
sqrt(0)*sqrt(3)
sqrt(0)*sqrt(1)
sqrt(1)*sqrt(2)
sqrt(1)*sqrt(2)
citation(package='ergm')
library(foreign)
library(readstata13)
dat = read.dta13('//Users/TScott/Downloads/educationexpansion2015.dta')
mod1 = lm(tertiary~gnp+totpop+intergov+centgov,data=dat)
summary(mod1)
mod2 = lm(tertiary~gnp+totpop+intergov+centgov+gnp:intergov+centgov:intergov,data=dat)
summary(mod2)
anova(mod1,mod2)
mod2
BIC(mod2)
BIC(mod2)
logLik(mod2)
logLik(mod2)
BIC(mod2)
mod2
mod2
?summary
library(stargazer)
stargazer(mod2)
AIC(mod2)
logLik(mod1)
logLik(mod2)
logLik(mod1)
nobs(dat)
dim(dat)
summary(mod1)
library(xergm)
help(package='xergm')
detach("package:xergm", unload=TRUE)
remove.packages("xergm")
install.package('//Users/TScott/xergm/')
install.packages('//Users/TScott/xergm/')
install.packages('//Users/TScott/xergm/',repos=NULL)
install.packages('//Users/TScott/xergm/pkg/',repos=NULL)
install.packages('//Users/TScott/xergm/pkg/',repos=NULL,type='source')
library(xergm)
?gergm
install.packages('//Users/TScott/xergm/branches/',repos=NULL,type='source')
install.packages('//Users/TScott/xergm/branches/gergm/',repos=NULL,type='source')
install.packages('//Users/TScott/xergm/branches/gergm/src/',repos=NULL,type='source')
source('//Users/TScott/xergm/branches/gergm/R/gergm.R')
library(ergm)
matrix(rnorm(100),ncol=10)
dat = matrix(rnorm(100),ncol=10)
?gegm
?gergm
gergm(dat ~ edgeweight)
gergm(form)
form = dat ~ edgeweight
gergm(form)
library(RCurl)
getURL('https://data.guidestar.org/v1/exchange/7831216.xml')
6.703-2*(0.308)
research = 0:25
6.703-2*(0.308) * research
0.2089 - 0.1199
(.2089 - .1199)
con <- file("test.log")
sink(con, append=TRUE)
sink(con, append=TRUE, type="message")
# This will echo all input and not truncate 150+ character lines...
source("script.R", echo=TRUE, max.deparse.length=10000)
# Restore output to console
sink()
sink(type="message")
# And look at the log...
cat(readLines("test.log"), sep="\n")
?Startup
setwd('//Users/TScott/Google Drive/elwha/')
list.files()
